## 001 add two numbers

### 问题描述
两个单向链表，存储两个整数；链表每个节点存储一个非负整数，且逆序存储，要求计算两个链表的和

**Input**: (2 -> 4 -> 3) + (5 -> 6 -> 4)

    **Output**: 7 -> 0 -> 8

### 个人思路

    刚看到这个问题，考虑到主要问题是相加之后进一位，以及两个链表长度不同的相加问题；所以我的算法分两步：

    - 首先同时遍历两个链表，根据next属性是否为None，分出较长和较短链表
    - 保存当前链表为较长的那个，然后拿较短的链表依次加上，遇到和超过9的要加到当前链表下一位

    由于情况考虑的不全，在提交测试时犯错多次，要考虑的情况有：长度是否相同，最后一位是否进位，以及多次进位。

### 答案思路

    同时相加两个链表相同位置的值，假如其中一个不存在值了，就加0，直到处理完最长的那个链表，算法步骤：

    - 初始化，特别的维持一个头节点，不含真实数据
    - 开始遍历两个链表。取当前值，如果无值置为0，计算和，使用**／ ％**分别确定当前值以及下一位要加的值
    - 循环结束，判断是否增加新节点；返回头节点的下一个节点

    时间复杂度和算法复杂度都为O(m, n) 因为只遍历一遍；保存结果的链表比最长链表多一个，即头节点

### 总结

    - 在开始解答之前，要先理清算法，尽量要简单
    - 考虑可能出现的情况，并在代码中做出处理
    - 测试的代码还需要改进
