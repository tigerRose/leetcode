## 实现正则匹配的. *

### 问题描述

实现正则匹配的. * 功能

\. 表示任意的一个字符

* 表示前面的单个字符重复n次，n可为0

**Input** isMatch('aa', 'a')

**Output** False

**Input** isMatch('aa', 'aa')

**Output** True

**Input** isMatch('aa', 'a\*')

**Output** True

**Input** isMatch('aab', 'c\*a\*b\*')

**Output** True

### 个人思路

对于不包含. * 的情况,直接比较两个字符串是否相等即可；对于. 也比较好判断，当成任意的单个字符；再复杂的情况就没有思路了。

### 答案思路

采用递归方法，因为 * 要依赖前面字符，所以它至少出现在第二个位置；假如第二个字符是 * 则有两种匹配方式，一个是舍去已有的 * 的pattern，比如'aab' 'c\*a\*b\*', 'c\*' 的模式可以丢弃，一个是第一个字符匹配了，可以删掉第一个字符，接着查找，如'aaa' 'a\*' 这种情况。假如第二个字符不是 * ,则第一个字符必须匹配，然后字符串和pattern都删掉第一个字符，再递归下去。

判断第一个字符是否匹配，就是pattern的字符要么等于字符串的对应字符，要么是 .

另一种实现方法是动态规划，它包含两种实现思路，一个是自顶向下，一个是自底向上。

自顶向下的方式中，维持了一个相关表，记录字符串和pattern不同长度时的值，这样可以减少重复的计算。

